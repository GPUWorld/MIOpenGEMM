#include <string>
#include <sstream>

#include <tinygemm/betackernelutil.hpp>
#include <tinygemm/kernelsnips.hpp>
#include <tinygemm/tinygemmerror.hpp>
#include <tinygemm/config.hpp>

namespace tinygemm{
namespace betac{

//const std::string cl_file_f32_path(PATH_BETAC_KERNEL_DIR + std::string("betackernel_f32.cl"));
//const std::string cl_file_f64_path(PATH_BETAC_KERNEL_DIR + std::string("betackernel_f64.cl"));

//std::string get_cl_file_path(char fchar){

  //std::string cl_file_path;
  //if (fchar == 'f'){
    //cl_file_path = cl_file_f32_path;
  //}
  //else if (fchar == 'd'){
    //cl_file_path = cl_file_f64_path;
  //}
  //else{
    //std::string errm = "fchar has value `";
    //errm += fchar;
    //errm += "', which is not valid. It should be either `f' or `d'. This error is being throunw from set_betackernel_sizes, in betackernelutil.cpp";
    //throw tinygemm_error(errm);
  //}
  
  //return cl_file_path;
//}




void set_betackernel_sizes(char fchar, bool isColMajor, bool tC, unsigned m, unsigned n, unsigned & dim_coal, unsigned & dim_uncoal, size_t & betac_global_work_size, size_t & betac_local_work_size){
  if (isColMajor == true){
    dim_coal = tC ? n : m;
    dim_uncoal = tC ? m : n;
  }
  else{
    dim_coal = tC ? m : n;
    dim_uncoal = tC ? n : m;
  }
  
    
  auto betac_parms = kernelutil::get_integer_preprocessor_parameters(get_betac_kernel_string(fchar));       
  
  if (betac_parms.count("N_WORK_ITEMS_PER_GROUP") + betac_parms.count("WORK_PER_THREAD") != 2){
    throw tinygemm_error("It is required that both N_WORK_ITEMS_PER_GROUP and WORK_PER_THREAD are defined in the scaling kernel, something looks weird here.");
  }
  
  betac_local_work_size = betac_parms["N_WORK_ITEMS_PER_GROUP"];
  size_t work_per_thread = betac_parms["WORK_PER_THREAD"];    
  size_t n_betac_threads = dim_uncoal*(dim_coal/work_per_thread + ((dim_coal%work_per_thread) != 0));
  size_t number_of_betac_work_groups = (n_betac_threads / betac_local_work_size) + ((n_betac_threads % betac_local_work_size) != 0) ; 
  betac_global_work_size = number_of_betac_work_groups*betac_local_work_size;
}



















std::string get_betac_kernel_string(char fchar){
  
  
  std::stringstream ss;
  
  ss << 

R"(

/* This kernel is NOT generated by a Python script! 
 * It is used to perform the beta*C step in GEMM, 
 * where recall GEMM has C <- alpha*A*B + beta*C
 * It is not simplt an axpy, as when ldc is not minimal, 
 * C is not a cotiguous chunk of memory.  */

/* The number of values from C which each a non-edge work-item will scale be beta */
#define WORK_PER_THREAD 4

/* TODO : does nvidia support this? Will Navi support this? */
#define N_WORK_ITEMS_PER_GROUP 64

/* TODO : figure out where to set TFLOAT (as per _32 kernel) */

)";
  
  if (fchar == 'd'){
    ss << "#define TFLOAT double";
  }
  
  else if (fchar == 'f'){
    ss << "#define TFLOAT float";
  }
  
  else{
    std::stringstream errss;
    errss << "unrecognised fchar " << fchar << "in get_betac_kernel_string";
    throw tinygemm_error(errss.str());
  }
  
  ss <<
  
R"(

__attribute__((reqd_work_group_size(N_WORK_ITEMS_PER_GROUP,1,1)))
__kernel void heeltemal(const unsigned dim_coal, const unsigned dim_uncoal, const unsigned ldc, const unsigned c_offset, __global TFLOAT * c, TFLOAT beta){
/* n_work_groups : number of work groups (determined by host from dimensions of the problem)
 * dim_coal : less than or equal to ldc, this is size in the contiguous direction (m for c matrix if col contiguous and not transposed) 
 * dim_uncol : the other dimension of the matrix */


  c += c_offset;
 
  unsigned group_id = get_group_id(0);
  unsigned local_id = get_local_id(0);
  unsigned global_id = group_id*N_WORK_ITEMS_PER_GROUP + local_id; 
  
  unsigned n_full_work_items_per_line = dim_coal / WORK_PER_THREAD;
  unsigned n_work_items_per_line = n_full_work_items_per_line + (dim_coal % WORK_PER_THREAD != 0);
  
  unsigned n_full_work_items = n_full_work_items_per_line*dim_uncoal;
  unsigned n_work_items = n_work_items_per_line*dim_uncoal;
  
  unsigned start_uncoal = 0;
  unsigned start_coal = 0;

  bool is_in_full_zone = (global_id < n_full_work_items);
  if (is_in_full_zone){   
    start_uncoal = global_id / n_full_work_items_per_line;
    start_coal = WORK_PER_THREAD * (global_id % n_full_work_items_per_line);
  }
  
  else if (global_id < n_work_items){
    start_uncoal = (global_id - n_full_work_items)% dim_uncoal;
    start_coal = WORK_PER_THREAD*n_full_work_items_per_line;
  }

  c += start_uncoal * ldc;
  c += start_coal;

  if (is_in_full_zone){
    #pragma unroll WORK_PER_THREAD
    for (unsigned i = 0; i < WORK_PER_THREAD; ++i){
      c[i] *= beta;
    }
  }
  
  else if (global_id < n_work_items){
    for (unsigned i = 0; i < (dim_coal % WORK_PER_THREAD); ++i){
      c[i] *= beta;
    }
  }
}


)";

  return ss.str();
}






}
}







